IN PROGRESS:
* app:hand-list should have a way to filter the rows by tournament number


STILL TODO:
* I wonder if using redis as the store for django-eventstream would noticeably improve things -- currently we use our database, and sending an event does a *lot* of queries.

  The redis backing store doesn't yet work correctly, though; I submitted [a patch for it](https://github.com/fanout/django-eventstream/pull/159/files).  The patch was accepted, but doesn't seem to have yet made it into a release (as I write this, the current release is 5.3.2; presumably, my fix will be in 5.3.3).

* Think hard about that limit of 40 postgresql connections -- wouldn't that mean I could never have more than 40 people playing at once?

  I wonder if switching the eventstore to redis (as above) would reduce the number of needed postgresql connections.

* After we've finished a hand, we see the _everything_read_only view. Sometimes that view shows a link to the current hand; but sometimes it doesn't.  I assume the latter happens when we're waiting for the next round to start.  Reloading the page (eventually) causes that link to appear; but this page should have the usual "listen for an SSE and update itself" logic, just for that link.

* Consider switching from "django-types" to "django-stubs", because the former still doesn't know that the HttpResponse class has a "text" attribute, whereas [the latter does](https://github.com/typeddjango/django-stubs/commit/c3b4a7a7189ce7591b097ba54287e0d9c956fafe).

* everything-read-only view should update automatically via SSE, just as the interactive views do.

* *STILL* rethink permissions.  See `docs/view-and-control.org`.

  I actually did this in "main" but it triggers some sorta race condition, leading to an assertion failure, in main ðŸ˜­

* scrolling from my hand, through the dummy, to the current trick, can be tedious if both hands have a long suit.  Clicking the little left'n'right arrows doesn't scroll by the entire <li>; instead it seems to scroll by the width in pixels of the visible area.  This is a reasonable thing for a scrollbar to do, but it's not convenient here.  So either
  - make it scroll by one <li> at a time, instead; or maybe
  - bring back the little dots along the bottom that did exactly that

* We send an SSE event containing the hand-div on every play, but about half of that div -- all the "toast" stuff -- never varies.  We'd save perhaps 1K per event if we only sent the four suit divs.

  Dunno if this would save significant time, memory, or CPU; but it's an idea.

* I broke God-mode :-(  One way to easily fix this would be to restore the "legacy" hand view, as above.  Might's well just have it permanently in god-mode.

  Another idea: just add a couple more <li>'s to the carousel views, so that each compass direction is represented.

* What should I do about a player who doesn't call or play within a reasonable amount of time?

  - certainly allow people at the table to yell at them via chat
  - perhaps "mark" them as an "unreliable player" or something, and make that mark visible to everyone?
  - perhaps discreetly scroll their interactive-hand thingy to show either the bidding box or the cards

* Make error pages extend the same base.html template that everything else does.  For example: I'm not logged in, and am looking at <http://127.0.0.1:9000/hand/1/>, whose entire content is `<html><head></head><body>This tournament (#1) won't yet complete until 2035-05-13 02:41:08.570023+00:00, so anonymous users such as yourself can't see this hand now.</body></html>`.  That's informative, but it'd be more useful if there were, say, a "home" link, &c.

* Terminology trouble: I use the word "hand" to refer to two different things:

  - A Django model that represents one board, four players, and a table display number
  - The set of cards belonging to one of those four players

  I don't think I've wasted a week due to this confusion (yet), but it's a ticking time bomb.

* Clicking "Skip the deadline" is sometimes slow.  I suspect it's creating synthetic users, and doing the deliberately-slow-password-hashing-thing for each.

* The SSE events for "a call was made at table X" and "a play was made at table X" should be readable by *all* users, regardless of whether they're sitting at the table, so their browsers will update when they watch the hand; currently those players are getting 400s when listening to `/events/hand/xxx/`.

  Of course, I better censor the events so that they don't reveal the calls, or the cards played, to players who haven't yet played that board.

  This *might* be obviated by all the work I'm doing on the "carousel-via-css" branch.

* Allow players to register an email address, and once they've done so, let them see hands in progress in tournaments in which they're not playing.

  The idea is: if *they* know that *I* know their email address, they'll be less likely to divulge what they see to players in those hands; and in general, will be more civilized.

  Maybe make the "who looked at which hands when" information visible to everyone, as further disincentive.

* Allow humans to submit feedback via a form or something.

  Only let them do this if I've got a confirmed email address for them; I imagine that'd reduce spam.

  I *think* "Getting a confirmed email address" is something that django, or a widely-used third-party library, can do for me.

* player_list ought to let you click a column header to control the sort order.  The default order should be "most-recently-active players first".

* Replace `app.models.tournament.check_for_expirations` with something more sensible
  - I've got a "django-q2" branch that uses a third-party scheduler; iirc it kinda mostly works.
  - I've also got a [Django-tasks](https://github.com/realOrangeOne/django-tasks) branch; that was a struggle from start to finish, and I never got it working. There's a [Django Enhancement Proposal](  https://github.com/django/deps/blob/5746805dfb062a99555b5e5bbc5b1685212aba2c/accepted/0014-background-workers.rst#L26) for it.
  - [Some dude on discord](https://discord.com/channels/856567261900832808/857643169046462475/1349500371378372640) wrote <https://tkte.ch/chancy/>, and mentioned it to me as a possible alternative
  - <https://django-tasks-scheduler.readthedocs.io/en/latest/> also exists! Ai yi yi, paradox of choice

  [Tyler Kennedy](https://github.com/tktech/) says:

    > (I'm biased, Chancy is my project)
    >
    > IMO, It's a common problem and they all tend to have their own tradeoffs - throughput and parallelism vs features, easy of use vs flexibility. My chancy isn't django-specific, has lots of features out of the box, and you can customize it extensively. The trade off is that it won't scale to hundreds of millions of jobs a day like celery+rabbit, and has more complexity in the initial setup (since it's all plugins)
    > django-tasks possibly has the smallest feature set of all of them, but it's goal I believe is to be a reliably available, simple option with strong integration. Eventually you can write your own django extensions that need simple background workers and as long as you target django-tasks it'll work regardless of what the end project is actually running.
    > Django-q2 looks like it lands in the middle for features but has strong support for several different backends

* Consider logging directly to S3: https://docs.docker.com/engine/logging/drivers/awslogs/

* Renaming a player (via the admin site, or a postgres client) causes ... all sorts of chaos.  Apparantly I store player names somewhere (maybe the cached hand transcript) and freak out when I cannot find a player of that name?

  Maybe change `player_who_may_call` and `player_who_may_play` to return directions instead of players.

  Also: maybe only ever pass primary keys to the bridge library (where it wants a name).

* After finding a partner, the next step should be a choice:
  - join a tournament
    Maybe you should get a chance to choose a tournament style, or the time it starts, or something
    This should bring you to https://bridge.offby1.info/players/?has_partner=True&seated=False&exclude_me=True&tournament=123
  - just futz around at a table for fun
    This should create synths to play with if there isn't already a "fun" table with an open slot
    The boards should NOT be the same boards that were generated for a tournament

  I guess our constraint about tournaments should change from "only one running tournament at a time" to, I dunno, "no more than one tournament whose signup deadline hasn't passed".  Might be OK to have two or more tournaments whose *play* deadlines haven't yet passed, though.

  OTOH, perhaps there should be *three* tournaments signing up at a time, spaced 8 hours apart, so that people around the world can find a convenient time to play.  Gotta plan for success!

* God Mode doesn't show all four hands during the auction; only during play.

* An RSS feed! Maybe each completed hand, or each completed tournament, would appear in it.

* Whatever happened to lobby chat?  It must have slipped into a crack at some point.

    fc053e10f2103a096c21a882428e38c0a80169ce
    Author:     Eric Hanchrow <eric.hanchrow@gmail.com>
    AuthorDate: 2024-08-19 15:29:33 -0700

    Nix lobby view.

    Now the "lobby" link goes to the player list, with seated players filtered out.

  Yikes, that was a long time ago.

* Consider alternate HTTP client (as opposed to "requests"): <https://github.com/florimondmanca/httpx-sse>

* Consider alternate ASGI server (as opposed to "daphne"): uvicorn + <https://github.com/sysid/sse-starlette>

* A legend! The hand detail should explain that
  - the little downarrow is the trick's led card
  - the sparkles indicate the winning card in the trick
  - the green glow indicates the player whose turn it is to play a card.

  Maybe hovertext, and maybe an actual map-like legend box in a corner near the top.

* Somehow visually distinguish cards of the trump suit? Glowing! Sparkles!

  https://www.perplexity.ai/search/using-css-or-bootstrap-how-can-A5U0WSQKTdS172ms6crEdQ

* Maybe prevent p1 from partnering up with p2 if they haven't played exactly the same sets of boards.  Otherwise they'll have an awkward encounter if the server refuses to let p1 play a board he's already played, even though p2 hasn't yet played it.

* Rethink at least some of my URLS -- e.g. when I am looking at hand 97, and click a card to play it, the POST goes to e.g. "/play/94/".  I'd have expected it to go instead to "/play/97/", but that 94 is a *seat_id*, not a *hand* ID.  Confusing.

* Maybe have one player -- django admin, perhaps -- have super-user powers: can see all cards, can poke the bot, &c, even in "prod".

* In the hand archive view:

  - Maybe have a thingy which, when I hover over one of the cards in the hand, it points to the trick in which that card was played?
  - Or have it be a link instead of a tooltip?  And the destination -- the row in the 13-row table -- should also have a link to take you back to the hand, so you don't have to scroll around to get back.

    JS magic that just scrolls the page to the appropriate point might work as well as links.

* Crazy idea for enforcing an upper bound on a table's "tempo":

  Return a 50whatever "throttled" response to any play or call post that comes too soon after the previous one.  Include a header that says when it's OK to try again.  That header's time should be e.g. one second in the future.  I might have to teach the browser to automatically retry; the alternative would be an annoying popup.  If the latter, at least I should show some visual thingy that makes it clear when it's OK to call or play.  (A shrinking bar, maybe?)

  Perhaps allow each table to set its own tempo, down to some minimum that will keep the server unstressed, and the browsers capable of following along (1/2 second might be OK).

* "Claim" and "Concede" buttons, at least if you're declarer

* when brenda speaks to james, but james' browser is looking at anything other than brenda's page, james needs to get an alert.
  In particular: I should make this like every other website with built-in chat:
  - some icon-y thing in the upper-right that gets a red dot if there's an unread notification
  - that icon-y thing is a link that takes you to a page that looks like every other chat:
    * column at left with a list of "rooms"
    * one of those rooms would be messages from the system that include "someone yoinked you into a partnership" or "your partner dumped you" or whatever
    * main area is the list of messages to the selected room, newest last

* chat log should scroll to bottom on page load, the way the auction log does.

  Otherwise, if it's got a lotta crap in it, I wind up looking at the oldest (i.e., least-interesting) stuff.

* django_web_messages (as opposed to my chat messages) aren't displayed as soon as they're generated; instead, I only notice them when I refresh the page, and then there's a backlog.

  I assume django_web_messages is designed to display only when I refresh the page; although istr seeing something somewhere that makes them pop up as alerts or something.

* when bob logs out, his name should vanish from the "lobby"

  ... although if I'm consistent, bob shouldn't be in the lobby if he's never logged in; and yet, my "generate_fake_data" tool creates lots of users who have never logged in.  Maybe I should teach it to log half of them in, or something.

  It's not obvious how to tell if a player is logged in.  There's a `django_sessions` table which appears to hold, I guess, cookie data; but it's not obvious how I can connect that to a Player.

* After each hand has been played:
  - Before the table vanishes, maybe the players can chat with each other?

MAYBE TODO:
* Reconsider sqlite -- [this](https://gcollazo.com/optimal-sqlite-settings-for-django/) strongly suggests it's viable for smallish projects such as this.

DONE:
* Performance, as usual

  For the last week or two I've been running "big_bot_stress" a lot, and watching the request latencies.  With the tempo at 0 -- i.e., each client hitting the server as quickly as it can -- typical p50 latency is maybe 500ms, p99 is 750ms.  Yuck!

  I notice the CPU is more or less pegged at 100%.  Siamak says if the CPU is pegged, you can't learn anything interesting about performance; so I should increase the delay (i.e., decrease the tempo) until CPU is, I dunno, 50%, then capture some traces and see what I see.

  Notes from a week of struggling with performance monitoring:

  - Almost all the tools are flaky, which wasted my time.  Specifically: pyinstrument consumes so much memory that it's not worth using; and I've blown through my free-tier quota on Sentry, so I can't use that for profiling.

    Also, I was able to get self-hosted sentry working *somewhat*, but it doesn't offer profiling.  No idea if that's a bug, or what.  I've since shut down the VM on which I'd had it running, since it was kind of expensive.

  - In prod, with 64 players (a "16x16" movement), performance is, bad, but (surprisingly) not awful.

  - The grafana suite, and in particular "pyroscope", are the only things I've found that even *might* be helpful.

* There's something fishy about dates in the admin page; I haven't narrowed it down.  But something weird happened just now: I started a tournament normally, with a single human and (I guess) 7 bots.  I was bored, so I used the admin page to change the tempo; then  when I reloaded a web page, it said

  ```
  AssertionError at /hand/1/
  How do I (Board #1 t#1, group A, Neither side vulnerable, dealt by North) even exist if the tournament signup deadline hasn't yet passed?!
  ```

  Which says to me that the date forms in the admin page were set to something weird, and by saving my "tempo_seconds" change, I also inadvertently messed up the deadlines.

  I reproduced the problem, and noticed the UPDATE is funny-lookin'

  `2025-06-13 14:24:13.522 UTC [43] LOG:  statement: UPDATE "app_tournament" SET "boards_per_round_per_table" = 1, "is_complete" = true, "display_number" = 1, "signup_deadline" = '2025-06-12 16:17:48-07:53'::timestamptz, "play_completion_deadline" = '2025-06-12 16:32:48-07:53'::timestamptz, "tempo_seconds" = 2.0 WHERE "app_tournament"."id" = 1`

  See the time-zone offset?  It's `-07:53` -- that's bogus; it should be either `-07:00` or `+00:00`.

  Removing the "tz_detect" app and middleware fixes the problem :-|

  Working around it as described [here](https://github.com/adamcharnock/django-tz-detect/issues/80) *really* fixes it :-)

* Maybe put an X-Request-ID header on all responses? That way the API bot could log that after it gets a response.  Might make it easier to match up the bot's logs with the server's.

  I thought I was doing this, but making a call in the browser, with the developer tools on, certainly doesn't show that header in the POST respose.

  I think I just need to set `'REQUEST_ID_RESPONSE_HEADER'` to True in the settings.

* add a bit of logic to suppress this common warning

    django-1  | _valchek ... 2025-06-04T19:32:26+0000 INFO  request_id=none player.py(249) svc 'svc -d' for _valchek's bot (52)
    django-1  | 2025-06-04T19:32:26+0000 WARNING request_id=none player.py(263) svc b'svc: warning: unable to chdir to 52: file does not exist\n'
    django-1  | _valchek done

  Surely, if we're *stopping* a bot, it's not a problem that the bot's directory doesn't exist.

* Consider that "how do we run it" (locally vs local docker vs remote docker) is orthogonal to "which set of django settings do we use" (dev vs prod).  Fiddle the justfile recipes to let me choose both those things independently.

* Restore the tempo attribute on a tournament, and have the bot honor it.

  That way it'd be easy to speed up an all-bot tournament.

* carousel_style_auction doesn't indicate that a hand has been abandoned.

  Repro steps:
  - `just restore < ../bob-is-ready-to-bid-hand-1.sql`
  - `just migrate && just --no-deps runme`
  - go to <http://localhost:9000/hand/1/>; log in as bob
  - new browser window with new identity; log in as _kima
  - have _kima "Splitsville"
  - observe that both browser windows, even after hitting F5, still show the interactive view.
    They should should the everything-read-only view, with a big indicator that the hand was abandoned.

  Done, but it could be better: currently you have to hit F5 to turn the interactive view into the everything-read-only view.  Ideally, the browser would do that for you as soon as the hand gets abandoned; this should be easy with another SSE event and another clause in the javascript magic.

* At the end of a hand, display a button (where "Next board plz" used to be) that takes us to the current hand.

* Perhaps I should restore the "legacy" hand view, but only for observers (i.e., users who are logged in, but haven't signed up for the tournament).  That way I can ensure that the carousel hand view is seen only by authenticated users, and thus can refer to `user.player` in its template.

* If I'm not looking at the "current trick" slide, it can acquire crucial information (namely: cards played by other seats), and then disappear, without me ever seeing it.  Imagine I lead a card, and don't scroll away from my hand.  Now three other players will play; one of them wins the trick and leads to the next.  Eventually my hand's background will turn light green, telling me it's my turn to play the trick ... but I won't have seen the previous trick -- the three cards that followed mine are now gone.

  So, maybe ...

  âœ“ automatically scroll to the current trick as soon as I've played a card?
  âŒ§ replace the "current trick" slide with a much smaller doohickey on every remaining slide?
  âŒ§ Add a "previous trick" slide (perhaps above the "current trick" slide)?
  âŒ§ Have the server enforce a pause of a couple of seconds before anyone can lead to the 2nd-13th tricks?

* I have changed the previous scheme of "reload the entire page whenever we get a server-sent event" to "when we get a server-sent event, redraw just the relevant bits", so that the user is entirely in control of what gets scrolled when.

  Which HTML things need to get updated?

  | when                | HTML to include | which channel & why         | current status |
  |---------------------+-----------------+-----------------------------+----------------|
  | auction: every call | current auction | hand: observers             | ok             |
  | auction: every call | bidding box     | player: so they can call    | ok             |
  | play: every play    | our hand        | player                      |                |
  | play: every play    | dummy           | hand: observers and players |                |
  | play: every play    | current trick   | hand: observers and players | ok             |

  Maybe I should have more than just two channels.  Here I propose some, showing the URL, channel name, and description for each:

  | url                                               | channel name                           | wozzit fur                                                                                                                |
  |---------------------------------------------------+----------------------------------------+---------------------------------------------------------------------------------------------------------------------------|
  | events/player/html/hand/<player_id>/              | player:html:hand:{player_id}           | for human player using a browser. Payload is HTML for their bidding box or hand, as appropriate.                          |
  | events/player/html/chat/<receiving_player_id>/[a] | player:html:chat:{receiving_player_id} | for human player using a browser. Payload is HTML for an incoming chat.                                                   |
  | events/player/json/<player_id>/                   | player:json:{player_id}                | strictly for the bot.  Shows calls and plays in the player's current hand.                                                |
  | events/table/html/<hand_id>/                      | table:html:{hand_id}                   | for observers and the player: shows the current auction when that's relevant; otherwise shows current trick and the dummy |

  [a] the message will include the name of the sender; the system will both add that name, and prohibit illegal chats (like from one partner to another when seated).

  - probably a channel for lobby chats, although those fell off the face of the Earth long ago :-)

  I don't have a "table:json" channel.  Such a channel would make sense, so that I could send calls and plays just once, instead of four times; but it'd require that I figure out how to let the bot listen to two channels "at once" -- this hypothetical table:json channel, *plus* the existing player:json channel.  (Now that I think about it, there might not be any truly private information in that latter existing channel!)

* Do the carousel thing to the auction, just as we did to the play.

  I've marked up the divs with some new ids.  The divs that we want to include in the carousel are
  - "auction"
  - "make-me-a-li" (that's the bidding box)
  - the contents of hand-div

* Make the cards more visible during play, by only showing one hand at a time!
  Currently I've got room to show all four hands; during play you get to see your cards, plus the dummy's.
  Maybe instead I should only show your cards -- i.e., zoom in -- and have some sort of interaction to let you flip between your cards and the dummy.  That interaction would have to be *easy* and *obvious* and *fast*.

  I'm thinking a carousel ([CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_overflow/CSS_carousels) or [bootstrap](https://getbootstrap.com/docs/5.3/components/carousel/)) might be the thing.  For the auction: you'd have one pane showing the bidding box, and another showing the auction-so-far.  For the play, you'd have one pane showing your cards; one showing the dummy; and one showing the current trick.

* I have some references to e.g. `"four_hands_partial_endpoint": reverse("app:four-hands-partial", args=[hand.pk]),` which I suspect are obsolete
  At least some are not obsolete -- the chat system still uses them

* Consider using flexbox for the card display; see https://www.youtube.com/live/hrzNaWFsP_4 for tons of detail.

* I've got backwards-compatibility kludges here and there, to deal with "old-style" tournaments (i.e., those that lack deadlines).  If so, kill that code.

* When creating synthetic opponents, create enough (not just two) so we get two tables, hence a realistic movement.

* Use [the time element](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/time) where appropriate.

  Done, in a couple places; although the benefit isn't clear.

* Completed tournaments have a summary showing each pair along with their score in matchpoints.  Allow sorting by various columns -- partners and score, certainly.

  Gonna try "django-tables2" again.

* The `app:tournament` view displays the movement as a grid.  Each cell should be a link to the relevant hands (if they exist).

* MOVEMENTS

  I must be getting cocky; now that tournaments mostly work, this is the only missing thing I can think of.

  There might be a couple of movements to choose from, plus "no movement at all" (which is what we've currently got); each tournament would be associated with exactly one such, and it cannot be changed once the tournament is created.

* Ensure that timestamps (in particular, tournament deadlines) show up in the browser in the user's preferred time zone.
  - https://docs.djangoproject.com/en/dev/topics/i18n/timezones/#selecting-the-current-time-zone is one (rather tedious) way to do that;
  - maybe I can just embed calls to the Javascript `Date` function in the web pages, thereby letting the browser handle it
  - django-tz-select seems to work fine!

* Somehow stress the "expiring-deadlines" branch.  I won't feel comfortable merging it into main until then.

* Maybe give some idea of user activity, in the lobby: e.g. if a user's "last_login" was a while ago, make the font dim; or if they last posted a chat message or sat at a table or took an action in a game.

* Another idea for end-of-tournament: when we create a tournament, we associate with it two timestamps in the future:

  * One is the "joining deadline" -- after this time, no more tables can join the tournament.

    If this deadline passes, and there isn't a reasonable number of players (eight?) for a tournament, then make some up with synths.

    How would players "sign up" for an upcoming tournament? ðŸ¤”
    *Who* would sign up for a tournament -- a player, or a pair?
      - If a player, I might want to enforce that they have a partner at signup time
        Or maybe not!  If not, then when they search for a suitable partner, it should exclude players who are already signed up for some other tournament.  Or maybe it should include them, but *indicate* that they are so signed up (so that they can chat and perhaps agree on a tournament to enter)

        OK here's an idea.
        New model: TournamentSignups.  The table is basically a tournament ID and a player ID.
        Unique constraint on that pair of columns, or perhaps just the player ID (since it seems wrong to sign up for more than one tournament).
        When a player signs up, we
        - reject them if the tournament is not in OpenForSignup
        - reject them if they have no partner
        - automatically sign up their partner as well
        When the signup deadline passes, the tournament code
        - seats all the players who are signed up (confirming that each still has the same partner who is also signed up)
        - deletes the corresponding entry from the TournamentSignups table

    - Should it be possible to cancel a signup?  If so, what happens?
      Seems like if a tournament is complete, we shouldn't have people signed up for it.

    - Should splitsville un-sign-up the relevant players?
      Yes, since I go to some effort to prevent singles from joining the tournament in the first place.

  * The other is the "play deadline" -- after this time, any tables that haven't finished all their boards are rudely ejected.  Dunno what to do about the hand that they *have* finished (maybe exclude them from appearing in the board-archive view?).

    This time should be the joining deadline + however much time seems reasonable to play all the boards in this tournament.

    This way, when you join a tournament, you'll know for sure when you'll be able to see your results (assuming you finish up in a reasonable time).

  * Idea: when we're waiting for the signup deadline, and someone loads a page that shows that deadline (e.g. <http://localhost:9000/tournament/5/>), we should see if that viewer (or their partner) are the only non-synthetic players signed up for that tournament.  (Unless people discover this site and start using it For Realz, this is overwhelmingly likely to be true at all times.)  In that case: display a button that says "Aw man, miss me with this signup deadline; I wanna play NOW".

* On [the tournament list page](/tournament/), have the English timestamps (e.g. "two minutes from now") update in real time

* Hands should have nice consecutive display numbers, just like ... uh ... tables do.

  Find some general way to do this; it feels wrong to have to write code to make this happen.

  I'm trying to avoid actually doing the above; and instead, just fiddling templates and strings to make the hand's "provenance" (i.e., tournament, table, and board) clear.

* Ponder: if a tournament is still running, but one player has played all the boards, should they be allowed to create a new tournament?  If so, that'd mean there is more than one "current" tournament, and I'd probably get confused.  But if not, they cannot play until the existing tournament finishes, which it might never.

  Simplest thing: set a "django message" that says something like "no tournament for you, this tournament is still running", then redirect to a list of hands that are still being played (so we can at least have something to watch while we wait).

  Another question: when should we create a new tournament --

  * When someone clicks "Next Board", and that tournament is found to be complete?; or maybe
  * When someone makes the 52nd play in some hand, that turns out to be the final hand in that tournament?

* Tournaments display their PK, instead of a display number; PKs aren't necessarily contiguous :-|

* What with all the recent terse_description stuff, I believe I no longer indicate vulnerability during the auction.

* Improve the "play summary" at the bottom of the hand archive view: I can never follow it!

  I designed it to conform to the "Bridge Writing Style Guide by Richard Pavlicek.pdf", but just because that dude says to use it, doesn't mean it makes it easy for me.

  Perhaps create an alternative layout that makes more sense, and have a little toggle switch with which the viewer can flip from one layout to the other.  Label them "Pavlicek" and "Modern"; and save their choice in the Player or User object (or some other table that is one-to-one with Users).

  Another idea: just add two skinny columns to the right of the existing display.  In each trick row, one column will have a mark if the trick was won by north/south; the other column will have a mark if it was won by east/west.

  I think of the two columns as having different marks: the n/s one will be a sort of vertical blob like `|`; the e/w one will be a horizontal blob like `-`.  They are to suggest the position of the relevant hands in the above hand layout.

* The "Number of boards played" column on `/table/` is ambiguous -- it counts boards that aren't yet complete.

  It should probably show a number corresponding to *completed* boards, and then show a `+` if there's one in progress.

* Most places where a player's name appears -- in particular, the header row of the auction history, and the "four-hands" div -- should be links to their detail pages.

* Come up with a more-reliable way to visually distinguish synths from humans.

  Right now, synths have names that begin with `synthetic_`, and those names are *usually* (not always) festooned with little robot icons ðŸ¤–ðŸ¤–.  But both those indicators can be spoofed -- a human can sign up with a name that includes those things.

  So I should choose something that can't be spoofed -- text style, perhaps.

* I think I've seen the "Redouble" button inactive when it should be active.  Something like

  - North bids 1 Club
  - East doubles
  - South should be able to redouble here.  Let's say they pass
  - West passes
  - North should be able to redouble here.

* The hand detail page is a mess -- specifically, the large type at the top:

| Board #5 (tournament 2; currently_running; 16 boards), North/South vulnerable, dealt by North | Table 20, Hand 317 (Board #5 (tournament 2; currently_running; 16 boards), North/South vulnerable, dealt by North): 3 calls; 0 plays |
| Auction: Incomplete                                                                           | {'N/S': 0, 'E/W': 0}                                                                                                                 |

  That's waaay too much redundant information.

  How about:

  One big line that tells you *which* hand you're looking at -- tournament number, board number, hand number.
  And another that tells you about the *state* of the hand: auction, trick count.

* Make it obvious for a new user what they need to do to start playing.  Some sort of old-school "Wizard" seems appropriate.

  I'll consider this done because as of fc4f51a, Xterm ("oldxterm" on Discord) says she got it working easily.

* Let users create synthetic players, if there aren't enough already to play with.

  Also: don't create *any* synthetic players in generate_fake_data; let the first human player see a totally empty tournament, since they'll easily be able to create friends to play with.  Well, maybe create one table's worth; I dunno.

* Along with the above, ensure there are always enough unpartnered bot players to accomodate a newcomer.

* Replace the BotPlayer model with a simple boolean field on the Player model (like it was not long ago).

  This way I'll be able to easily make a database constraint that says "we gotta have allow_bot_to_play_for_me set if we also have synthetic set".

    Note that, given two boolean fields on the model, there are in theory four possible states; in our case, exactly three of those are allowed.

* version 0a1dfaf 2025-01-31 (refs/heads/main) 2025-02-01T03:47:01+0000.sql : Template error when bob looks at https://django.server.orb.local/hand/40/

  Something about "current_player"

* Make it obvious for a new user what they need to do to start playing.  Some sort of old-school "Wizard" seems appropriate.

* Don't show the "table up with these dudes" button if the partnership on that line is already seated!  Duh.

* The http://localhost:9000/players/?lookin_for_love=True page has a table whose rightmost column is "Let's All Make A Table Together".  But that's wrong sometimes -- if I'm looking for a partner, e.g., it should say "Partnerup", and have the "partnerup" button in the relevant rows.

* Not clear how to reproduce this, but I think I simply did "docker compose up --build", and then I noticed that none (or few) of the bots were actually running, despite some players having "allow_bot_to_play_for_me" be True.

  I guess I need to do something at startup to ensure that all the bot services are up?  I'd have thought daemontools would have taken care of that for me.

  On futher reflection, I think most of the bot players weren't seated for some reason, which prevents their bots from coming up.

  So now, the question is: what brings the bots up normally? Answer: the Dockerfile invokes `bring_up_all_api_bots` before starting `svscan`.

* Put the green highlight on the player whose turn it is to *call*, just as we do for when it's their turn to *play*

* At the end of a tournament, something should create a new one.  In general, we should have an invariant that says there is always exactly one uncompleted tournament.

  Players who have finished playing in one tournament will be free to join the next one, somehow (contra the below point).

* At the end of a tournament, shouldn't all the players be splitsvilled? (No.)  And ejected from their tables?  (Yes.)

* Access control:

  In general, we want something like
  * every time a player sees even a single call, or a single card played, from a given board -- regardless of whether they played it themselves, or were kibitzing -- they must be marked as being "tainted" for that board
  * such a taint will prevent that player from playing that board in the future.

  Unrelatedly:

  * Anonymous players must never see any calls or plays from a tournament that is still running

* The hand-event channels have zero auth -- anyone can receive any of them.

* Big-ish: proper hosting and deployment.

  Up until now, I've been using tailscale's "funnel" feature mostly because it gets an SSL cert for me.  But it prevents me from using a sensible domain like `bridge.offby1.info`, and just feels temporary (see `README.hosting.md`).

  So I'm experimenting with "caddy" -- another container in the docker-compose stack.  It works great!  Stuff is now running at https://bridge.offby1.info.

* It seems wrong for "Table.next_board" to just plop you into a new tournament.  Perhaps I should require players to explicitly ask to join a tournament.

* Explore https://django-htmx.readthedocs.io/; it appears to have been written by a grownup

* At https://ubuntu-2gb-hil-1.tail571dc2.ts.net/hand/24/, I (bob) have chosen to *not* have the bot play for me, and I'm declarer ... but the bot is playing for dummy :-|

* The hand-event channel names are just integers.  This is annoying; instead of just "2", it should be something like "hand:2"

* Fix the bottom-of-the-table-is-cut-off as shown at `mobile-rendering-trouble.png`

  -- Apparently I considered that png file "obsolete" as of

     commit 5bc78b2e4f11a45d946b69301960f00099471cd0
     Author: Eric Hanchrow <eric.hanchrow@gmail.com>
     Date:   2024-11-19 09:29:00 -0800

         Nix a couple of obsolete files

      mobile-rendering-trouble.png | Bin 211247 -> 0 bytes
      1 file changed, 0 insertions(+), 0 deletions(-)

* Read about django-eventstream, in particular: how does it ensure that events get delivered?  Picture this:
  - server sends event "foo".
  - nobody is around to listen for it.
  - it's effectively lost; the next time someone listens for it, they won't see it.
  - also, perhaps related: consider what happens if the server stops and restarts while the old bot is running.  I suspect it won't resume playing; I often connect to the "prod" instance and find that a few tables are blocked on the bot making a call or a play.
    The new API bot might eventually solve this, if I use it instead of the old bot, and somehow ensure that
    - it always comes up after stopping (i.e., make it a service)
    - it learns how to ask for events that it might have missed when it was dead, or at least ask "hey is it my turn" as soon as it comes up
  - [the readme][1] says "Events can be persisted to your database, so clients can recover if they get disconnected.".  What does that even mean?  How would a client tell the server "please send me events from the past"?
    Apparently every event ever sent gets persisted to a table named `django_eventstream_event`, along with a timestamp; I wonder if anything ever trims old stuff off that table?
  - [the "stream-reset" event][2] seems relevant
  - https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events doesn't clear anything up
  - kinda looks like the client needs to keep track of the event IDs that it's seen, and pass the largest to the server, in effect saying "don't just show me events from now on; but rather, show me events since this here number from the past".
    [Here](https://github.com/valberg/django-sse/commit/7af129efd87241bdffbd9abb46256074362161bc) is an example of how the server might handle this.

  -- We're mostly doing the right thing here, although we're ignoring the "stream-reset" event.

* The frequent "count" calls in `hand.Hand.get_xscript` are slow -- the output of pytest-profile, says that we called "query:609:count" almost six thousand times in test_hand_visibility!

  -- I'm now caching the entire transcript, and updating it whenever there's a new call or play.  There's no longer any need to check if the transcript is current.

* The bot replays *all* messages for its player when it starts, but it'd make more sense for it to only replay the messages from the most-recent hand.

* Big: write an API so that strangers can write their own bots.  Presumably using <https://www.django-rest-framework.org/>
  Note: django-rest-framework has proven quite fiddly; I'm currently moving away from it, and replacing it with dirt-simple written-by-hand serialization in the library.

  Of course, switch the API bot to use it, once it exists.

  Next up: have the apibot maintain its own HandTranscript, with which it can ... wait for it ... come up with its own calls and plays.
  This also entails figuring out how to do a POST or a PUT via DRF.  Not at all obvious.

* Logged in as player 1, <https://laptop.tail571dc2.ts.net/hand/?played_by=1> shows "Sorry, bob (bot-powered), but you have not completely played board Board #6 (tournament 1), so later d00d".  But when I click that link, it (correctly) shows me the hand in progress.

* generate_fake_data seems to add players and tables every time it runs:

    prod_settings: HOST_HOSTNAME='Erics-Work-MacBook-Pro.local'

    players:   0%|          | 0/20 [00:00<?, ?p/s]
    players:   0%|          | 0/20 [00:00<?, ?p/s]
    2024-12-14T23:44:19+0000 DEBUG request_id=none hand.py(131) create Just created Hand 118: 0 calls; 0 plays; dealer is South
    73 players at 17 tables.
    prod_settings: HOST_HOSTNAME='Erics-Work-MacBook-Pro.local'

    players:   0%|          | 0/20 [00:00<?, ?p/s]
    players:   0%|          | 0/20 [00:00<?, ?p/s]
    2024-12-15T00:19:21+0000 DEBUG request_id=none hand.py(131) create Just created Hand 125: 0 calls; 0 plays; dealer is South
    76 players at 18 tables.
    prod_settings: HOST_HOSTNAME='Erics-Work-MacBook-Pro.local'

    players:   0%|          | 0/20 [00:00<?, ?p/s]
    players:   0%|          | 0/20 [00:00<?, ?p/s]
    2024-12-15T00:19:23+0000 DEBUG request_id=none hand.py(131) create Just created Hand 126: 0 calls; 0 plays; dealer is South
    79 players at 19 tables.
    prod_settings: HOST_HOSTNAME='Erics-Work-MacBook-Pro.local'

    players:   0%|          | 0/20 [00:00<?, ?p/s]
    players:   0%|          | 0/20 [00:00<?, ?p/s]
    82 players at 19 tables.

  It should instead merely *ensure* that the requested number of players (typically 40) exists, and do nothing if so.

* Add "tournaments" to the list of links in `app/templates/base.html`.  It'd just go to `/board/` with a query string narrowing the board list to that particular tournament.

* Take another crack at request IDs, using [this](https://github.com/dabapps/django-log-request-id) -- it appears very similar to django-request-id (middleware plus a log filter) but is not moribund, and [explicitly suppports ASGI](https://github.com/dabapps/django-log-request-id/issues/74) (which I suspect django-request-id does not).

* Investigate https://django-request-id.readthedocs.io/en/latest/. Looks slick, and I always want this.
  Couldn't get it to do anything, and it seems so old and unmaintained that I hesistate to hack on it.

  Might not be hard to simply redo it -- all you need is a middleware and a logging filter, I think.

* Consider speeding up test_table_view by using a Django fixture to install a completed hand, rather than building it up one call and one play at a time.

* https://laptop.tail571dc2.ts.net/hand/?played_by=1 shows "Page 1 of 7" at the bottom ... but the "next" and "last" links don't include the `?played_by=1` query thing :-(

* More than one tournament!

* $ just restore < prod.sql  && just migrate && just shell -c "'Tournament.objects.create()'"

  reliably causes

    django.db.utils.IntegrityError: duplicate key value violates unique constraint "app_tournament_pkey"
    DETAIL:  Key (id)=(1) already exists.

  This was due to [this](https://docs.djangoproject.com/en/5.1/ref/databases/#manually-specifying-values-of-auto-incrementing-primary-keys), which I never stumbled upon until after I opened [a bug complaining about it](https://code.djangoproject.com/ticket/35916).

* https://erics-work-mbp.tail571dc2.ts.net/board/ sorts boards by their primary key, not by their "number"

* It seems that if I've played all 16 boards, and then do splitsville, partnerup, and sit at a new table ... I get board #1 again.
  See the BUGBUG comment at Table.next_board

* Bob (player 1) played a zillion hands, but then did "splitsville", and now https://erics-work-mbp.tail571dc2.ts.net/hand/?played_by=1 shows 0 hands :-(

* The "new-hand" event includes ALL THE CARDS FOR ALL THE PLAYERS ðŸ¤¦

* The hand, while we're playing, does not show a running total of tricks taken by each side.

* The server is taking maybe 30 seconds to start via docker-compose -- I suspect the time is in "collectstatic", due to my recently having actually gotten that config right, and perhaps because I'm asking for compression.

      8966431144c039092231ff33a5ae4013695bca24
      Author:     Eric Hanchrow <eric.hanchrow@gmail.com>
      AuthorDate: 2024-10-22 16:51:47 -0700
      Static files speedups:

  Maybe I can, in effect, cache the `static_root` directory by having docker mount that as a volume, so that it persists from one container to the next.

  I tried "collectfasta", in a branch of that name, but it didn't do anything.

  Maybe I'm only using three of the static files, but am processing 200 of them (actual numbers may vary), in which case, just nuke the ones I'm not using.

* Provide a view or two that shows what a player has done in the past.
  In particular, what tables they played at, and who else was at those tables.

* Add a view for examining what you've done in the past -- what tables you've been at, and the associated transcripts.

* When I'm done playing a hand, let me see other tables' scores for this board.

  `[h.xscript.final_score() for h in b1.hand_set.all() if h.is_complete]`

* Indicate the winning trick with some sort of effect, like glowing or pulsing, rather than a sparkly emoji -- those take up space and thus mess up the layout.

* brandon (player ID 806) is logged in, and is looking at [heidi](https://teensy-info.tail571dc2.ts.net/api/players/805/).  It sure looks like he can toggle the "let bot play for me" switch :-|

  I guess the policy should be: only player X gets to modify player X's stuff.

  What other stuff is leaking out?

  Ugh, https://www.django-rest-framework.org/api-guide/permissions/#djangoobjectpermissions suggests that I need a 3rd-party backend to provide object-level permissions.

  - https://django-guardian.readthedocs.io/en/stable/userguide/index.html probably tries to solve this, but the docs are disappointingly sloppy and not-written-by-Native-english-speaker-y.
  - https://github.com/dfunckt/django-rules looks sane.

* Trivial idea: have the bot get its "tempo", not from a hard-coded constant in "delay_action", but rather from something in the database.
  That way I could tweak it while it's running.

  Maybe I should attach this number to the table, instead of the hand.

* Set page titles, so the browser history shows something more informative than

  ```
  5:06â€¯PM Bridge erics-work-macbook-pro.tail571dc2.ts.net
  5:06â€¯PM Bridge erics-work-macbook-pro.tail571dc2.ts.net
  5:06â€¯PM Bridge erics-work-macbook-pro.tail571dc2.ts.net
  5:06â€¯PM Bridge erics-work-macbook-pro.tail571dc2.ts.net
  5:05â€¯PM Bridge erics-work-macbook-pro.tail571dc2.ts.net
  ```

* The layout of the play record doesn't quite conform to what [the style guide](Bridge Writing Style Guide by Richard Pavlicek.pdf) (page 5) says:
  - I should have a column for the trick number *and* the compass direction of the leader;
  - The column headers should be "Trick", "Lead", "2nd", "3rd", "4th";
  - The 2nd, 3rd, 4th columns should omit the suit symbol if it's the same as the led suit

* Speaking of the hand archive: I should get rid of the three_by_three_trick_display when the hand has been completely played; it's distracting

* Couple problems with the hand archive:
  - At https://erics-work-macbook-pro.tail571dc2.ts.net/hand/81/archive/, the play record has entries like `(sitting ) played â™£2 (sitting ) played â™£3`.  That is: the player's names and compass directions are missing.
    This is probably fallout out from commit 3c5ddc67a8870c6193909ee6584b7da076bed5d9 in the library.

* I see a lot of hand summaries like "Auction is incomplete; 27 cards played".  That makes no sense; if cards have been played, obviously there must be a contract.  Right?  RIGHT??

* https://erics-work-macbook-pro.tail571dc2.ts.net/hand/69/ shows `322:swabhiman_das (bot)` and yet [the admin page](https://erics-work-macbook-pro.tail571dc2.ts.net/admin/app/player/322/change/) shows (correctly) that the "Allow bot to play for me" box is unchecked.

* Maybe teach the bot to play just a *little* less stupidly?  Second-hand-low, third-hand-high, e.g.?

* Think of some way to move the boards amongst the partners, so that a given board gets played more than once!
  I.e., a proper tournament, with movements and shit.  Can't really score until we do this.
  <https://en.wikipedia.org/wiki/Duplicate_bridge>
  ("Teams"? "Pairs"? "Individual"?)

  [Barometer](https://en.wikipedia.org/wiki/Duplicate_bridge_movements#Barometer_games_and_online_bridge_movements) might be the way to go.

* Still seeing occasional update problems in the browser: the browser fails to redraw after the server sends an event.

  This happens most often when the bot is sending events faster than one per second per table, but I've seen it during normal play, too.

  I wonder if I've got htmx swapping the OuterHTML of something, and while that swap is happening perhaps the target element has vanished from the DOM?  In which case, perhaps always doing *inner* swapping could help, since then the target will always be present?

  Consider just *reloading the entire page* every time anything happens.  This will, theoretically, be less efficient than just reloading *some* of the page; but might be so much simpler -- and efficient enough -- that it's worth doing.

  I mean, the page isn't all that big! Right?

  Well (without the debug toolbar) it's 17 KB which *seems* like a lot, but I dunno.

  It wasn't being compressed ... adding gzip middleware brings it down to 3 KB (but, curiously, not much faster, at least when running locally).  Let's use keep using gzip.

* When I look at the table detail view, and the bot is playing all four players, and a hand gets passed out, the browser does load the "archive" page ... but then it just sits there; the bot does *not* press the "new board plz" button.

  Not entirely sure this is a bug, tbh; I think the bot *has* pressed the button, but since the page doesn't automatically reload, we don't notice.

* Have the bot delay, not just after *it* has made some action at a table, but after *any* action, even by humans, has happened.

  Currently if the bot is sitting to the left of a human, and a human takes a while to do whatever, the bot will immediately act.

  - done in commit 59889a54539b2f34174b31a4752d0cfd5026d447: "Greatly complexify, but also speed up, the bot"

* Add a little summary like "down 2", "made the contract", or "made the contract with 1 overtrick" to the hand archive

* IDEA: consider storing effectively-cached information on a model instance.

  E.g., if I fetch a Hand object, and want to examine the associated xscript, until now I've either recomputed the xscript from scratch (which is expensive if I do it many times), or cached the whole thing (which is unreliable if I add a call or play and then later access that now-stale cache).

  But perhaps I can cache manually, and intelligently, without getting too complex.  Just store ... something as an ordinary instance attribute, and have the xscript method consult that data and then only fetch from the db those rows that are "newer" than what's in the cache.


* Too many redirects:

    2024-10-18 17:32:42,127 INFO     "192.168.97.1" - - [18/Oct/2024:17:32:41 +0000] "GET /hand/92/ HTTP/1.1" 302 - "https://erics-work-macbook-pro.tail571dc2.ts.net/hand/?page=6" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36"
    2024-10-18 17:32:42,150 INFO     "192.168.97.1" - - [18/Oct/2024:17:32:41 +0000] "GET /hand/92/archive/ HTTP/1.1" 302 - "https://erics-work-macbook-pro.tail571dc2.ts.net/hand/?page=6" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36"
    2024-10-18 17:32:42,168 INFO     "192.168.97.1" - - [18/Oct/2024:17:32:41 +0000] "GET /hand/92/ HTTP/1.1" 302 - "https://erics-work-macbook-pro.tail571dc2.ts.net/hand/?page=6" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36"
    2024-10-18 17:32:42,184 INFO     "192.168.97.1" - - [18/Oct/2024:17:32:41 +0000] "GET /hand/92/archive/ HTTP/1.1" 302 - "https://erics-work-macbook-pro.tail571dc2.ts.net/hand/?page=6" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36"

* THE hand_list has "auction" and "trick_counts" columns.  That information shouldn't be visible to everyone; instead the deets should only be seen by people who have already played that board.  Otherwise it should be very vague:
  - auction should either be "complete" or "incomplete"
  - play should be number of cards played, if incomplete; or "complete"

* Rethink access control.  I've spent the last couple of days willy-nilly adding restrictions here and there; there are probably more places that need restrictions, that I've not yet thought of.

  Ideally I'd have some way of prohibiting player X from examining cards Y that works at a low level, so that I only need that logic in one place.

  The models that need restricted access:
  - Call
  - Play
  - Board

  ... although now that I think about it, is there any reason we'd show e.g. *some* Calls to a player, but not all of them?

  Now to enumerate all the views that access Board, Call, or Play:
  - drf_views.BoardViewSet
  - drf_views.CallViewSet
  - drf_views.PlayViewSet
  - hand.hand_list_view
  - hand.hand_archive_view
  - hand.four_hands_partial_view
  - hand._interactive_view
  - hand.bidding_box_partial_view
  - hand.auction_partial_view


* HEY! Bob can see *all* the cards at <https://erics-work-macbook-pro.tail571dc2.ts.net/api/boards/> ... I thought I fixed that :-(

  ... I need to put ACLs around "list" as well as around "retrieve", it seems.

* BUG -- `_display_and_control` is messed up.  It lets bob -- who is currently West at table 2, playing hand 22 -- see West's cards on hand 1, board 1, even though amy is sitting there, not bob.

  I made a couple of fixes to _display_and_control, can't remember exactly which one fixed this.

* It will play 1,000,000 boards without stopping; nothing pays attention to

  Fixed this recently

* The "new board plz" button appears to do nothing

  - I replaced the htmx stuff with an ordinary form

* It occurs to me that most players should *not* be allowed to see a table review.  The only ones who can are
  - those who were at that table; or (more broadly)
  - those who have played that board already
  For now, since there are no movements, that means: only those who were at that table.

* In the table list view, links should go directly to the archive, if the play at the table has finished.

* Rename the "is_human" field on the Player model, and change the text of the "make me a bot" button ...  The idea isn't
  that a player "is a bot" or "is human", but rather, that the player wants the bot to call or play for them.

  * related: I really really want a little slidey-switch widget for the "let the bot play for me" thing.  Functionally it's a check box, but standard HTML check boxes are ugly.

    [bootstrap's switches](https://getbootstrap.com/docs/5.3/forms/checks-radios/#switches) are it!

* After each hand has been played:
  - reveal the original cards
  - compute the score, although I don't think I ever got around to teaching the library how to do that :-)
  These were done in b735de4 and ae4c4caf

* If the bot is playing two adjancent hands -- e.g., East and South -- it courteously waits a second in between those plays.  However, if I, Mister Human, play East, and the bot is playing South, it'll pounce the instant I make a play.  This is not only rude, but might be messing with the async crap in the browser (see below).

* I've seen the hand display fail to update after I play a card from the sole human's hand.

  In the browser console, I saw two messages like these

    Play event listener saw â™¦K, so it fetched /table/212/four-hands and /table/212/handaction-summary-status
    Play event listener saw â™£4, so it fetched /table/212/four-hands and /table/212/handaction-summary-status

  What's odd is that *I* played the â™£4, and my LHO played the â™¦K -- which means the listener saw the events out of order :-(

  I wonder if the listener somehow gets messed with when the browser reloads the partial?

  - as with most of these concurrency problems, I'm not *sure* that I've fixed it, but slowing down the bot again seems to have ameliorated it.

* https://erics-work-macbook-pro.tail571dc2.ts.net/table/152/archive e.g. shows two hands when run under daphne (i.e., in prod)

* I've seen the card display fail to become active after the bot plays (on the ec2 box, but not on my laptop).  This has happened a couple of times.

  Also, if all four hands are being played by the bot, sometimes it just appears to freeze; reloading the page resumes it. I saw nothing in the browser's console.

  Naturally it didn't repro the one time I actually tried to repro it.

  - I don't *deeply* understand this problem, but I consider it fixed, now that the browser reloads an order of magnitude less frequently :-)

* Maybe somehow visually distinguish whose turn it is?  It *is* possible to tell, but you gotta squint.
  What do we want to know?
  * Which cards can I, the human, play *right now*?
  * What other cards are in my hand, and the dummy?
  * If we're in a debug mode, what other cards are in the other hands?
  * Whose turn is it to play?

* Customize the 404 page that it at least has a link to home.

  Right now it's just "NOT FOUND" "The requested resource was not found on this server."

* Indicate the number of tricks taken by each side

* Try out <https://docs.djangoproject.com/en/5.1/ref/contrib/admin/admindocs/#module-django.contrib.admindocs>

* Not 100% sure what's going on, but it feels like: if *I* am making the opening lead -- i.e., declarer is to my right -- my cards buttons aren't active unless I reload the page.

  Two pieces to the fix:
  - send a message to the table that says "The auction is settled and the opening lead will be made by so-and-so";
    seems done, in `handrecord.add_call_from_player`
  - have the reload-the-cards event listener *also* trigger on that message, if so-and-so is in fact the browser user
    Or add a new listener just for this ðŸ¤·

  Addendum: *sometimes* the opening leader's bidding box doesn't go away ðŸ˜­; other times the "one Club played by bob, sitting South" message doesn't appear.

  I wonder: do multiple event listeners on the same page, listening to the same URL, interfere with each other? Like, each message gets delivered to just one of them?
  Or if not, might they interfere with each other when they go to fiddle the DOM?
  <https://htmx.org/attributes/hx-sync/> might be useful, although TBH I don't understand what problem that solves, nor what *my* problem is.

  I wonder: does the final fetch of some auction-related endpoint cause some JS to disappear, and it was that JS which was supposed to do the final fetch?

  Looks like after the final pass, megan -- the opening leader -- unsurprisingly failed to refetch the bidding box partial:

    Got request from megan at 54030
    Got request from bob at 54031
    Got request from katherine at 54024
    Got request from admin at 54010
    HTTP GET /table/14/bidding-box 200 [0.10, 127.0.0.1:54024]
    HTTP GET /table/14/bidding-box 200 [0.13, 127.0.0.1:54031]
    HTTP GET /table/14/bidding-box 200 [0.13, 127.0.0.1:54010]
    HTTP GET /table/14/four-hands 200 [0.21, 127.0.0.1:54030]

  - The fix was (I guess): realizing that `htmx.ajax` is *asynchronous*, and changing
    {
      htmx.ajax(update one bit of the page);
      htmx.ajax(update another bit of the page);
    }
    to
    {
      htmx.ajax(update one bit of the page).then(() => {
        htmx.ajax(update another bit of the page);
      });
    }
  I will guess this is because the second ajax call is silently ignored, as described [here](  https://github.com/bigskysoftware/htmx/issues/2147#issuecomment-1880142872)

* Gaah! At least when debug is True, East's buttons are active *regardless* of who is logged in!  I've got four humans at one table, and a browser window for each; and (once I reload all the pages to work around the below bug) the buttons are active in each window!

* How about an "I am human" toggle on each player's home page?  At least when DEBUG is True.

* Declarer needs to be able to control the dummy as well as their own hand
  There's two parts to this:
  - the bot needs to fiddle with the dummy exactly as much, or as little, as it fiddles with declarer
  - the "is this button active" stuff needs to make 'em active if request.player is dummy's partner

* Sentry caught a crash!  Very handy.

  https://eric-hanchrow.sentry.io/share/issue/414efa5798154d1a93e21eeb06d382bf/

  Seems it's in the library; I'd just bid 7NT and it was trying to find a legal bid beyond that, and presumably the only bids left were "Pass", which it weights at zero, and ...

* I can't articulate this precisely, but ... card buttons are often *too* dim.  It's ok for them to be really dim when they're in *my* hand, and they're not legal to play (i.e., they are a different suit than the led suit, and I have some cards of that led suit).  But when they're e.g. in the dummy's hand, and I'm not the declarer *and* it's not the dummy's turn to play, they should be easier to read.

  In general, there are two orthogonal dimensions to buttons:
  - active vs inactive
  - EZ to read vs deliberatly dim

  Here's a table.  By "border" I guess I mean `class="border border-success border-5"` around the entire hand -- it's ugly but gets the job done.

  | My turn to play? | Izzit a legal card? | how do things look?        | how "cards_as_four_divs" thinks of it |
  |------------------+---------------------+----------------------------+---------------------------------------|
  | no               | N/A                 | no border, clear, inactive | text                                  |
  | yes              | no                  | border, muted, inactive    | disabled button                       |
  | yes              | yes                 | border, clear, active      | active button                         |

* gotta display dummy's hand (to all players) after the opening lead

* Ugh, the bidding box doesn't go away after the auction is settled *unless* I reload the page.

  I need to (if I'm not already) send an "auction settled" message, or maybe the "someone played a card" message is the right place to handle that.

* Make the auction record vanish once the opening lead has been made.

* It looks like the played-a-card message is forcing the *auction log* to reload -- I've seen it jitter.

* Where it currently says "No bidding box 'cuz the auction is over", have it display, you know, the CONTRACT at this table :-|

* Find another color for inactive card buttons, to make them much dimmer or less saturated or something; it's not blindingly obvious that they're inactive.  Maybe `--bs-btn-disabled-color` and `--bs-btn-disabled-bg`?

  Now that I think about it, I might want the cards to look different during the auction than during the play.

  During the auction, they've got to be super-easy to read, since after all, you can't bid if you don't know what you hold.  BUT they should probably also clearly be un-clickable, since you can't play during the auction!  Not sure how to handle this.

* In the table list's auction status, don't just say "Incomplete"; say how many calls have been made.

* Dockerize the bot, now that I've done the web service.

* Somehow the cards in one dude's hand aren't sorted, even though they're sorted in the board:
  https://erics-work-macbook-pro.tail571dc2.ts.net/table/14 shows East holding 9, K, 4, J of diamonds (in that order);
  https://erics-work-macbook-pro.tail571dc2.ts.net/admin/app/board/14/change/ shows East's cards as "â™£2â™£6â™£Tâ™£Qâ™¦4â™¦9â™¦Jâ™¦Kâ™¥4â™ 3â™ 4â™ Tâ™ Q" (i.e., nicely sorted)

  Looks like models.Table.current_cards_by_seat returns a dict of *sets* of cards, and we all know sets aren't ordered.  Wtf was I thinking

* The auction log is missing some events, and fails to update thereafter, until I reload the page
  I see this in the browser's console

    htmx.min.js:1 htmx:swapError
    w @ htmx.min.js:1
    htmx.min.js:1 TypeError: Cannot read properties of null (reading 'insertBefore')
        at c (htmx.min.js:1:11666)
        at Me (htmx.min.js:1:12591)
        at _e (htmx.min.js:1:13292)
        at ze (htmx.min.js:1:14782)
        at e (htmx.min.js:1:46625)
        at Mn (htmx.min.js:1:47396)
        at p.onload (htmx.min.js:1:42510)
    w @ htmx.min.js:1
    htmx.min.js:1 Uncaught TypeError: Cannot read properties of null (reading 'insertBefore')
        at c (htmx.min.js:1:11666)
        at Me (htmx.min.js:1:12591)
        at _e (htmx.min.js:1:13292)
        at ze (htmx.min.js:1:14782)
        at e (htmx.min.js:1:46625)
        at Mn (htmx.min.js:1:47396)
        at p.onload (htmx.min.js:1:42510)

  But since I fixed the problem whereby the bot was sending events in rapid succession, this seems to be gone.

* Table 14's hand record looks like this
    No bidding box 'cuz the auction is over
    South at Table 14 played â™¦2
    West at Table 14 played â™¦T
    North at Table 14 played â™¦K
    East at Table 14 played â™¦8
    South at Table 14 played â™ 3
  That suggests that, even though North played the winning card, *South* led to the second trick.

  Also the opening lead is wrong -- the contract is "three notrump, redoubled, played by stephanie, sitting South" so West should make the first play.

* The bot sleeps too much!

  It needs to slow down the actions that it takes *at a particular table*, but if there are 100 tables, we don't want an action at the first to slow down all the others.

  This suggests keeping track of the time we last performed an action at a given table, and the next time we want to take action at that same table, deferring it until a second has passed.

  And that, unfortunately, suggests threads or async.  Or maybe one bot per table?

  - no need for async.

* Somehow ensure that "git pull" on the server code updates the library as well.
  git Submodules maybe?  Specifying a commit hash in pyproject.toml?

  That out-of-syncness was the cause of this:

    on commit 9088f1632af549e090694e960b6e84373bba82f3, on https://teensy-info.tail571dc2.ts.net/table/14, all the auction tables are empty

    I see "West 	North 	East 	South" but no further rows under that; the next thing down is " No bidding box 'cuz you are not at this table"

* In the table list, include the auction status, or play status, as appropriate.

* Performance.

  * Unit tests seem slow, too.  Again, it's _hashlib.pbkdf2_hmac.

  * pages load awfully slowly.  Even after paginating the player list -- so that only 10 players appear per page -- that page seems to take 500ms of CPU time on the server, and over three seconds to fully render.  That's nuts.
    Splitting settings into prod and dev seems to greatly speed up prod (that django debug toolbar is slow, it seems).

  * figure out why "generate_fake_data" only creates 7 players per second -- it otta do hundreds.
    Unsurprisingly, it's _hashlib.pbkdf2_hmac, whose whole purpose in life is to be slow.

* paginate the table list
  <https://spookylukey.github.io/django-views-the-right-way/list-view.html#displaying-a-list-of-objects> has an example
  or maybe just use datatables

* If the auction is incomplete, and request.user is seated at the table *but* its not their turn to call, disable the bidding box visually somehow.

* The auction history is one call per line, but I think newspapers used to display it with four columns -- one for each seat.  I think.

* Occasionally some page will take ages to load.  Like, right now http://localhost:8000/players/?lookin_for_love=True took 34 seconds.

  There are only 17 players.

  Nothing of interest in the stdout or stderr of daphne.

  I didn't think to look in the Django debug toolbar for timing info.

  <https://developer.chrome.com/docs/devtools/network/reference/#timing-explanation> says
  > Queueing. The browser queues requests before connection start and when:
  >    There are higher priority requests.
  >    There are already six TCP connections open for this origin, which is the limit. Applies to HTTP/1.0 and HTTP/1.1 only.

  I wonder if that's pertinent.  The browser is indeed using HTTP/1.1 (as revealed by opening the developer tools, clicking the "Network" tab, right-clicking any column, and selecting Protocol from the menu)

  -- I'm not *certain* this is fixed, but I don't think I've noticed this since I got Daphne to talk HTTP/2.  Note that this only helps if you're using SSL: <https://en.wikipedia.org/w/index.php?title=HTTP%2F2&section=6#Encryption> says

      Although the standard itself does not require usage of encryption,[49] all major client implementations (Firefox,[50] Chrome, Safari, Opera, IE, Edge) have stated that they will only support HTTP/2 over TLS, which makes encryption de facto mandatory.[51]

  Thank God Tailscale makes SSL easy.

* I had four browser windows open, each to a different player; all 4 players were seated at the same table.

  I clicked "splitsville" on one of them, then reloaded the others.  Each of the other three displayed

  AttributeError at /table/1
  'NoneType' object has no attribute 'name'
  /Users/not-workme/git-repositories/me/bridge/server/project/app/models/table.py, line 71, in libraryThing
  seat <Seat: EAST at Table 1 (NORTH: bob, EAST: None, SOUTH: aimee, WEST: None)>

* reload or hide (as appropriate) the bidding box when we get the "someone just made a call" message.

* bob is able to call at someone else's table!!

* catch the "illegal call" thing somewhere and return it as an HttpResponseForbidden or similar

* Only show bidding box if auction is incomplete, *and* request.user is seated at the table.

* AttributeError at /players/
  http://192.168.4.39:8000/players/?seated=False&lookin_for_love=False&exclude_me=True

  'AnonymousUser' object has no attribute 'player'

* DEAL THEM CARDS!!!

* the coverage report has a lot of "empty"s near the right margin, and "coverage html" prints `CoverageWarning: No contexts were measured`

* when not logged in, we still attempt to listen to server-sent events ... but fail with 400 (cuz that endpoint requires authentication, I guess).

  - I've definitely seen this recently, but ... I can't think of any page that calls addEventListener that doesn't also require login.

* The new "lobby view" ("/players/?seated=False") doesn't tell you how many *total* players there are.  (Because I nuked the " 3 / 15 players" thing)

  - Sure it does.  At least, it has done since I added Datatables.

* REGRESSION
  When sending a chat message, but failing -- because e.g. you or the recipient are seated at a table, there's no feedback about the failure.  Either
  - pop up a dialog with the body of the 403 response; and/or
  - just don't have the text area and "talk with" button visible in the first place.

  I guess I gotta fiddle with https://htmx.org/events/#htmx:responseError

* The datatables default of 10 entries per page isn't enough; make it 100 or something.

* See "trouble" in this directory.
  Dunno what happened exactly, but I had one browser window logged in as kelly, looking at anne, another (private) window logged in as anne and looking at kelly; and a mobile browser logged in as brett, looking at kelly.

  I tried sending a message from the first window (i.e., from kelly -> anne) and noticed that nothing happened.  I sent a message from the second window (anne -> kelly) and that worked OK.  Then after a while I saw the stack trace in "trouble".

  - gonna assume I fixed this, but ðŸ¤·

* Oy
  So anne is logged in, looking at kelly's page.
  kelly is anne's partner.
  brett is logged in, also looking at Kelly's page.
  When anne splitsvilles, brett doesn't find out.
  I think this means that the "viewer.pk" bit of the channel needs to be optional.
  Anyone who looks at a subject will subscribe to that empty-viewer channel, except for ... I guess ... the subject in question, or their partner.

* paginated the player list a while ago, by using datatables, which gives me pagination for free.

* rename the "foo-html-partial.html" files to "foo-partial.html"

* sam is looking at his own page
  bob is looging at sam's page
  They are partners
  sam clicks "Splitsville"
  bob's page doesn't update
  I suspect I need to spray more messages -- one to subject, viewer, and subject's partner

* I am sending the same blob of HTML to all browsers.  Specifically, if abigail and juan are partners, and each is looking at Juan's page, after some splitsville and parter-up, I see
    Hello, Juan
    juan: muh partner
  I think I need the channel to include both the logged-in user, and the "subject" (i.e., the user whose ID is in the URL); only then will the view have enough information to render the stuff correctly.

* BEEG BOOG: logged in as abigail on the phone, looking at the page for alan.
  meanwhile the browser is logged in as juan, and *it* is also looking at alan's page.
  When juan partners up, abigail sees "JUAN is muh partner" and "their partner is you! juan".

  I suspect I wrote the template partial on the assumption that there were only two people in the world -- the player and their partner.

* It should be blindingly obvious that you have a partner so you don't have to go around looking for another one.

* When someone clicks the "partner up" button, the other person needs to get an alert, telling them that that happened.
  And their "player detail" page, or at least some section of it, needs to refresh so that it now says who their partner is.

* When sending a chat message, make RET submit, so that we don't have to actually click on the button.
  Note that simply using htmx with `hx-trigger="keyup[key=='Enter']"` doesn't work on mobile, since they ain't no key events ðŸ˜­

* The chat log can get annoyingly long -- the new messages are at the bottom, so I gotta scroll to see them.

* When sending a chat message, the newly-appended log line isn't styled quite the same as those logs that were sent by the server when the page loaded.

* Write a player-list partial template.  It should include both the "lookin' for love" filter, and a new "are they in the lobby" filter.
  Use that on both "/players/" and "/lobby/" (distinguished only by different default settings on those filters)
  - It's not a partial; I just made "players" do double-duty

* When displaying the signup page, put text focus on the first field, so I can start typing without having to hit TAB

* Refactor: I've got two almost-but-not-quite-identical chunks of HTML for rendering a chat log: one in the lobby, one in the player detail.
  Ideas:
  âœ“ have a separate template that renders just that, and then stick the output of rendering that into the context of both lobby and player_detail
  âœ˜ use [django-template-partials](https://github.com/carltongibson/django-template-partials)
    - of course that will entail me looking again into HTMX 'cuz carlton sez it's the bee's knees

* when bob partners with tonya, I see `2024-08-16T16:08:06.412297+00:00` `bob` `Partnered with tonya` in the lobby chat, but no "tonya partnered with bob".  On the one hand, this seems fine; on the other hand, I expected to see both messages.
  - Calling this "done" without doing anything; the current behavior seems correct.

* combine PlayerMessage with LobbyMessage.  Maybe if the recipient is NULL that means it's a lobby message?  But then what do I do when I want to have messages directed at a table?  Maybe add a "recipient model" column, so that the target of a message can be NULL (meaning lobby), or anything with a django model.

* Inspired by https://spookylukey.github.io/django-views-the-right-way/, convert some CBVs into function-based views.

* Write my own `@logged_in_as_player_required` decorator, that is like `@login_required`, but checks that there is a corresponding Player object, and redirects with an error message.

* the "lookin' for love" dropdown is always set to "unknown" when the page loads, even if a filter is in effect.
  E.g. <http://localhost:8000/players/?&lookin_for_love=true> correctly displays only partner-ess players, but the dropdown shows "Unknown" when it should show "yes".

  Dunno what I did to fix this, really, apart from making it a lot simpler

* investigate partner weirdness.

  - create two unpartnered players -- `just drop pop --tables=0 --players=2` seems to work
  - log in as player 1
  - go to /player/2/; you'll see "Partner Me Up, Daddy-O"
  - duplicate that page.
  - click the button on one of the pages.  It updates appropriately: the button goes away, and it says "Alice is partnered with Bob" or whatever.
  - go to the other page.  Click its button.  You *should* see either the same "Alice is partnered with Bob" page, or even some sort of exception; but instead it just stays as is.
  - reloading the pages sometimes does nothing, sometimes "fixes" them (i.e., shows what I'd expected)
  - no interesting output in either the Unix console or the JS console
  - only clue: browser's developer tools show the POST data as
    `me=1&them=2&action=partnerup&action=partnerup` -- why is the "action" duplicated?

NOT DONE:
* I'm fuzzy on the details, but I think I was logged in as a player who wasn't the declarer or dummy; after the last trick was played, the browser loaded my "player home page" (e.g. `/player/1/`) instead of something more useful, like the next hand, or the review of the previous hand.

  I could not reproduce this; I only saw it load the `/hand/xyzzy/archive` page, which is fine.

* A scenario

  - I let the bot play for me
  - The hand completes, so I'm looking at the "next board plz" button
  - I change my mind and turn off the "let the bot play for me"
  - I click the "next board plz" button
  - I discover that the hand is in progress -- and if the auction is over, I don't get to see it.  I get to see the *contract* but not the calls that led up to it.

  I guess I need a "review the bidding" button? :-\

  Meh.  There's no longer any "next board plz" button :-)

* Consider passing a "read timeout" to the SSE client; I don't know exactly what this would do, but perhaps it would cause it to raise a StopIteration exception after that much time has passed with no events; that would be handy as a way to resynch.

  I confess I haven't tested this, but I'd *hope* that there's no need to do this, given that the serialized-hand view includes some event IDs, and the bot passes those back to the server when it starts the SSEClient loop.

* Consider some sort of partners-ranked-by-score page.  It would show each partnership (including those that have since split up); it'd be ordered by number of boards won by that partnership.

  This is close enough to the existing end-of-tournament score that I'm'a call it done.

* Seeing a number of `Invalid request: Can't resume session after stream-error.` errors in the console

  Haven't seen this in forever

* Both the "Table" and "Hand" models are effectively "join" tables for many-to-many relationships:
  - "Table" joins "Hand" and "Seat"
  - "Hand" joins "Call" and "Play"

  Perhaps officially recognize that by rewriting the relevant models to use ManyToMany fields.
  https://docs.djangoproject.com/en/5.1/ref/models/fields/#django.db.models.ManyToManyField.through

  Dunno what I was thinking -- calls and plays are many-to-one with hands, not many-to-many

* After each hand has been played:
  - I guess let any player break up the table
    - this would be tolerable if I did the "examining what you've done in the past" thing below, so that if the table vanishes on you, you can still examine the result at your leisure
  - Alternative: require unanimity.  Have four buttons, one for each player.  Only the one for the current player is active.  Each says "I'm done reviewing this hand"; once all four have been pushed, we do ... whatever it is we do next.  (Next board, presumably)
  Those things seem too disruptive in a tournament; I can't think of an equivalent from the real world of a duplicate club.

* When I toggle the "let the bot play for me" button, my name doesn't update from e.g. "bob (bot-powered)" to "bob (independent)" everywhere; rather, I have to reload the page to see the new status.  This is annoying.

  In theory I could fix this by making every spot that displays the name, and hence might need updating, into a partial, and have it reload as needed.  That seems so tedious, though, that my heart sinks just thinking about it.

  Perhaps https://alpinejs.dev/ would make it easier to handle this.  Perhaps it could replace much of the HTMX I'm currently using.  https://news.ycombinator.com/item?id=29319298 compares and contrasts the two.

  I no longer indicate bottiness in the player's name, so this is moot.

* Have the bot display a live-updating tableau where each row represents a table, and shows something like the remaining time before the bot will act, and/or the last thing it did, or something.

  Maybe use the "rich" library, and have it update every row every time it takes any action at any table.  It'd look kewl.

  -- The new API bot wouldn't have access to this sort of information.

* Think hard about transactions, and come up with a way to avoid this problem:
  - somehow, two client processes logged in as player one are participating in the auction (a web browser and a bot, say)
  - one of them makes an apparently-valid call:
    - it does a "select" of all the existing calls, sees that it's its turn
    - it does an "insert" of the new call
  - meanwhile, the other one does the same select at more or less the same time
    - and does its own "insert" of its own call
  I am not convinced that this will not wind up with both clients inserting calls, thereby robbing the next player of their opportunity to call.
  What I *want* to happen is: last writer loses.  I.e., the second client to *attempt to* insert gets some sort of exception, and the database only persists the first insert.

  Does django do this out of the box? Beats me.  Would I need to sprinkle some "atomic" fairy dust around certain chunks of code? Beats me.  Would I need to ask postgresql to use a fancy level of "transaction isolation"?  Beats me.

  Only way to know for sure is to come up with some sort of test case.

  -- This clearly happens already.  Dunno why I was worried about it.  The second process gets an "it's not your turn" exception.

* It occurs to me that the events pertaining to a hand should be *public* -- just the "new-hand", "someone made a call", and "someone made a play" events.  And maybe I can force the event IDs to be: zero for the "new-hand" event, 1, 2, 3 &c for the calls; and num-calls, num-calls + 1, ... num-calls + 52 for the plays.  That should make it easier for clients to "sync" up; or at least, when I see the event ID in a log message, it should be easier to tell what it's for.

  Per-player events, if we need them at all, would pertain to "here's your hand", although the transcript provides that, so ...

  -- I've got something like that, that I call a "serial_number".  It's basically the number of calls, plus the number of plays, that were present in the transcript before this call or play (i.e., serial_numbers start with 0).

* The bot still occasionally crashes because it receives an event like this

    MainThread INFO  bot.py 270 <-- {'new-hand': {'pk': 2, 'table': 1, 'board': 2}, 'tempo_seconds': 1.0, 'time': 1732107423.441545}

  But the "new-hand" event is supposed to (and, almost all the time, does) look like this

    MainThread INFO  bot.py 270 <-- {'new-hand': {'pk': 3, 'table': {'seat_set': [5, 6, 7, 8], 'id': 2, 'current_hand_pk': 3, 'tempo_seconds': 1.0}, 'board': 3}, 'tempo_seconds': 1.0, 'time': 1732107396.953585}

  Also, I see a whole bunch of "new-hand" messages with the same hand primary key.  WTF?

    2024-11-20T12:52:27+0000 MainThread INFO  bot.py 270 <-- {'new-hand': {'pk': 2, 'table': {'seat_set': [1, 2, 3, 4], 'id': 1, 'current_hand_pk': 2, 'tempo_seconds': 1.0}, 'board': 1}, 'tempo_seconds': 1.0, 'time': 1732107147.832227}
    2024-11-20T12:52:29+0000 MainThread INFO  bot.py 270 <-- {'new-hand': {'pk': 2, 'table': {'seat_set': [5, 6, 7, 8], 'id': 2, 'current_hand_pk': 2, 'tempo_seconds': 1.0}, 'board': 1}, 'tempo_seconds': 1.0, 'time': 1732107149.4633641}
    2024-11-20T12:52:34+0000 MainThread INFO  bot.py 270 <-- {'new-hand': {'pk': 2, 'table': {'seat_set': [5, 6, 7, 8], 'id': 2, 'current_hand_pk': 2, 'tempo_seconds': 1.0}, 'board': 2}, 'tempo_seconds': 1.0, 'time': 1732107154.3725948}
    2024-11-20T12:52:34+0000 MainThread INFO  bot.py 270 <-- {'new-hand': {'pk': 2, 'table': {'seat_set': [1, 2, 3, 4], 'id': 1, 'current_hand_pk': 2, 'tempo_seconds': 1.0}, 'board': 2}, 'tempo_seconds': 1.0, 'time': 1732107154.4819589}
    2024-11-20T12:52:34+0000 MainThread INFO  bot.py 270 <-- {'new-hand': {'pk': 2, 'table': {'seat_set': [5, 6, 7, 8], 'id': 2, 'current_hand_pk': 2, 'tempo_seconds': 1.0}, 'board': 2}, 'tempo_seconds': 1.0, 'time': 1732107154.6503448}
    2024-11-20T12:52:35+0000 MainThread INFO  bot.py 270 <-- {'new-hand': {'pk': 2, 'table': {'seat_set': [1, 2, 3, 4], 'id': 1, 'current_hand_pk': 2, 'tempo_seconds': 1.0}, 'board': 2}, 'tempo_seconds': 1.0, 'time': 1732107154.997817}
    2024-11-20T12:52:35+0000 MainThread INFO  bot.py 270 <-- {'new-hand': {'pk': 3, 'table': {'seat_set': [5, 6, 7, 8], 'id': 2, 'current_hand_pk': 3, 'tempo_seconds': 1.0}, 'board': 3}, 'tempo_seconds': 1.0, 'time': 1732107155.066463}
    2024-11-20T12:56:36+0000 MainThread INFO  bot.py 270 <-- {'new-hand': {'pk': 2, 'table': {'seat_set': [1, 2, 3, 4], 'id': 1, 'current_hand_pk': 2, 'tempo_seconds': 1.0}, 'board': 2}, 'tempo_seconds': 1.0, 'time': 1732107396.893606}

  At least on this branch, this is obsolete; that bot no longer exists.

* When clicking "New board plz", if the current hand is not the most recent, do nothing.

  I decided instead that it should take you to the current hand.  The idea is: if I'm just sitting back letting the bot play for me, I still need to click that button to resume viewing the action; but at least I'm not *creating* a new board that will then be abandoned.  (I'm actually not certain that was happening, but this way seems more solid).

[1] : https://github.com/fanout/django-eventstream?tab=readme-ov-file#django-eventstream
[2] : https://github.com/fanout/django-eventstream?tab=readme-ov-file#receiving-in-the-browser
