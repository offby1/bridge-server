STILL TODO:

* In the table list's auction status, don't just say "Incomplete"; say how many calls have been made, and perhaps show the dealer & vuln.

* Dockerize the bot, now that I've done the web service.

* Consider timestamps for important stuff, in particular calls and plays.

* Maybe a "Table" isn't worth modeling at all; instead model "games" or "hands" -- both current and past.  A "game" or a "hand" is pretty much what I'm now calling a Table -- four players plus a specific board, plus a possibly-complete transcript of what they did.

* Think of some way to move the boards amongst the partners, so that a given board gets played more than once!
  I.e., a proper tournament, with movements and shit.  Can't really score until we do this.
  <https://en.wikipedia.org/wiki/Duplicate_bridge>
  ("Teams"? "Pairs"? "Individual"?)

* It looks like the played-a-card message is forcing the *auction log* to reload -- I've seen it jitter.

* Make the auction record vanish once the opening lead has been made.

* Try out <https://docs.djangoproject.com/en/5.1/ref/contrib/admin/admindocs/#module-django.contrib.admindocs>

* Whatever happened to lobby chat?  It must have slipped into a crack at some point.

* If the auction is passed out, either shut down the table completely, or at least indicate that it's moribund.

* Think about optimization (without actually doing it, since that would be premature):
  Seems we're sending events to a "public" channel, which means if we have 1,000 browsers listening for those events, most of them will ignore most events (since bob only cares about events that affect him).

  So, consider which events really need to be public, and which can be "private".

  e.g player_detail_view sends "splitsville" (to the "partnerships" channel) in response to a player clicking the button, but surely only (at most) four players need to know about this *instantly*; other people can reload the page to find out who's partnered with whom.

  Otoh, a given player probably won't send that many messages; and sending a message is likely cheaper than rendering and returning a whole response, so ... ðŸ¤·

  Also it occurs to me that, if I want to have bot(s) to take the place of humans, they will need to know what's going on; and it might be simpler to have a single bot process that is aware of every event at every table, as opposed to lots of processes that each subscribe to just one "narrow" event channel.

* when brenda speaks to james, but james' browser is looking at anything other than brenda's page, james needs to get an alert.

* chat log should scroll to bottom on page load.

  Otherwise, if it's got a lotta crap in it, I wind up looking at the oldest (i.e., least-interesting) stuff.

* splitsville for someone seated needs to update the table detail that shows at the bottom of the page.

* django_web_messages (as opposed to my chat messages) aren't displayed as soon as they're generated; instead, I only notice them when I refresh the page, and then there's a backlog.

  I assume django_web_messages is designed to display only when I refresh the page; although istr seeing something somewhere that makes them pop up as alerts or something.

* Maybe give some idea of user activity, in the lobby: e.g. if a user's "last_login" was a while ago, make the font dim; or if they last posted a chat message or sat at a table or took an action in a game.

* when bob logs out, his name should vanish from the "lobby"

  ... although if I'm consistent, bob shouldn't be in the lobby if he's never logged in; and yet, my "generate_fake_data" tool creates lots of users who have never logged in.  Maybe I should teach it to log half of them in, or something.

  It's not obvious how to tell if a player is logged in.  There's a `django_sessions` table which appears to hold, I guess, cookie data; but it's not obvious how I can connect that to a Player.

* Provide a view or two that shows what a player has done in the past.
  In particular, what tables they played at, and who else was at those tables.

DONE:

* Somehow the cards in one dude's hand aren't sorted, even though they're sorted in the board:
  https://erics-work-macbook-pro.tail571dc2.ts.net/table/14 shows East holding 9, K, 4, J of diamonds (in that order);
  https://erics-work-macbook-pro.tail571dc2.ts.net/admin/app/board/14/change/ shows East's cards as "â™£2â™£6â™£Tâ™£Qâ™¦4â™¦9â™¦Jâ™¦Kâ™¥4â™ 3â™ 4â™ Tâ™ Q" (i.e., nicely sorted)

  Looks like models.Table.current_cards_by_seat returns a dict of *sets* of cards, and we all know sets aren't ordered.  Wtf was I thinking

* The auction log is missing some events, and fails to update thereafter, until I reload the page
  I see this in the browser's console

    htmx.min.js:1 htmx:swapError
    w @ htmx.min.js:1
    htmx.min.js:1 TypeError: Cannot read properties of null (reading 'insertBefore')
        at c (htmx.min.js:1:11666)
        at Me (htmx.min.js:1:12591)
        at _e (htmx.min.js:1:13292)
        at ze (htmx.min.js:1:14782)
        at e (htmx.min.js:1:46625)
        at Mn (htmx.min.js:1:47396)
        at p.onload (htmx.min.js:1:42510)
    w @ htmx.min.js:1
    htmx.min.js:1 Uncaught TypeError: Cannot read properties of null (reading 'insertBefore')
        at c (htmx.min.js:1:11666)
        at Me (htmx.min.js:1:12591)
        at _e (htmx.min.js:1:13292)
        at ze (htmx.min.js:1:14782)
        at e (htmx.min.js:1:46625)
        at Mn (htmx.min.js:1:47396)
        at p.onload (htmx.min.js:1:42510)

  But since I fixed the problem whereby the bot was sending events in rapid succession, this seems to be gone.

* Table 14's hand record looks like this
    No bidding box 'cuz the auction is over
    South at Table 14 played â™¦2
    West at Table 14 played â™¦T
    North at Table 14 played â™¦K
    East at Table 14 played â™¦8
    South at Table 14 played â™ 3
  That suggests that, even though North played the winning card, *South* led to the second trick.

  Also the opening lead is wrong -- the contract is "three notrump, redoubled, played by stephanie, sitting South" so West should make the first play.

* The bot sleeps too much!

  It needs to slow down the actions that it takes *at a particular table*, but if there are 100 tables, we don't want an action at the first to slow down all the others.

  This suggests keeping track of the time we last performed an action at a given table, and the next time we want to take action at that same table, deferring it until a second has passed.

  And that, unfortunately, suggests threads or async.  Or maybe one bot per table?

  - no need for async.

* Somehow ensure that "git pull" on the server code updates the library as well.
  git Submodules maybe?  Specifying a commit hash in pyproject.toml?

  That out-of-syncness was the cause of this:

    on commit 9088f1632af549e090694e960b6e84373bba82f3, on https://teensy-info.tail571dc2.ts.net/table/14, all the auction tables are empty

    I see "West 	North 	East 	South" but no further rows under that; the next thing down is " No bidding box 'cuz you are not at this table"

* In the table list, include the auction status, or play status, as appropriate.

* Performance.

  * Unit tests seem slow, too.  Again, it's _hashlib.pbkdf2_hmac.

  * pages load awfully slowly.  Even after paginating the player list -- so that only 10 players appear per page -- that page seems to take 500ms of CPU time on the server, and over three seconds to fully render.  That's nuts.
    Splitting settings into prod and dev seems to greatly speed up prod (that django debug toolbar is slow, it seems).

  * figure out why "generate_fake_data" only creates 7 players per second -- it otta do hundreds.
    Unsurprisingly, it's _hashlib.pbkdf2_hmac, whose whole purpose in life is to be slow.

* paginate the table list
  <https://spookylukey.github.io/django-views-the-right-way/list-view.html#displaying-a-list-of-objects> has an example
  or maybe just use datatables

* If the auction is incomplete, and request.user is seated at the table *but* its not their turn to call, disable the bidding box visually somehow.

* The auction history is one call per line, but I think newspapers used to display it with four columns -- one for each seat.  I think.

* Occasionally some page will take ages to load.  Like, right now http://localhost:8000/players/?lookin_for_love=True took 34 seconds.

  There are only 17 players.

  Nothing of interest in the stdout or stderr of daphne.

  I didn't think to look in the Django debug toolbar for timing info.

  <https://developer.chrome.com/docs/devtools/network/reference/#timing-explanation> says
  > Queueing. The browser queues requests before connection start and when:
  >    There are higher priority requests.
  >    There are already six TCP connections open for this origin, which is the limit. Applies to HTTP/1.0 and HTTP/1.1 only.

  I wonder if that's pertinent.  The browser is indeed using HTTP/1.1 (as revealed by opening the developer tools, clicking the "Network" tab, right-clicking any column, and selecting Protocol from the menu)

  -- I'm not *certain* this is fixed, but I don't think I've noticed this since I got Daphne to talk HTTP/2.  Note that this only helps if you're using SSL: <https://en.wikipedia.org/w/index.php?title=HTTP%2F2&section=6#Encryption> says

      Although the standard itself does not require usage of encryption,[49] all major client implementations (Firefox,[50] Chrome, Safari, Opera, IE, Edge) have stated that they will only support HTTP/2 over TLS, which makes encryption de facto mandatory.[51]

  Thank God Tailscale makes SSL easy.

* I had four browser windows open, each to a different player; all 4 players were seated at the same table.

  I clicked "splitsville" on one of them, then reloaded the others.  Each of the other three displayed

  AttributeError at /table/1
  'NoneType' object has no attribute 'name'
  /Users/not-workme/git-repositories/me/bridge/server/project/app/models/table.py, line 71, in libraryThing
  seat <Seat: EAST at Table 1 (NORTH: bob, EAST: None, SOUTH: aimee, WEST: None)>

* reload or hide (as appropriate) the bidding box when we get the "someone just made a call" message.

* bob is able to call at someone else's table!!

* catch the "illegal call" thing somewhere and return it as an HttpResponseForbidden or similar

* Only show bidding box if auction is incomplete, *and* request.user is seated at the table.

* AttributeError at /players/
  http://192.168.4.39:8000/players/?seated=False&lookin_for_love=False&exclude_me=True

  'AnonymousUser' object has no attribute 'player'

* DEAL THEM CARDS!!!

* the coverage report has a lot of "empty"s near the right margin, and "coverage html" prints `CoverageWarning: No contexts were measured`

* when not logged in, we still attempt to listen to server-sent events ... but fail with 400 (cuz that endpoint requires authentication, I guess).

  - I've definitely seen this recently, but ... I can't think of any page that calls addEventListener that doesn't also require login.

* The new "lobby view" ("/players/?seated=False") doesn't tell you how many *total* players there are.  (Because I nuked the " 3 / 15 players" thing)

  - Sure it does.  At least, it has done since I added Datatables.

* REGRESSION
  When sending a chat message, but failing -- because e.g. you or the recipient are seated at a table, there's no feedback about the failure.  Either
  - pop up a dialog with the body of the 403 response; and/or
  - just don't have the text area and "talk with" button visible in the first place.

  I guess I gotta fiddle with https://htmx.org/events/#htmx:responseError

* The datatables default of 10 entries per page isn't enough; make it 100 or something.

* See "trouble" in this directory.
  Dunno what happened exactly, but I had one browser window logged in as kelly, looking at anne, another (private) window logged in as anne and looking at kelly; and a mobile browser logged in as brett, looking at kelly.

  I tried sending a message from the first window (i.e., from kelly -> anne) and noticed that nothing happened.  I sent a message from the second window (anne -> kelly) and that worked OK.  Then after a while I saw the stack trace in "trouble".

  - gonna assume I fixed this, but ðŸ¤·

* Oy
  So anne is logged in, looking at kelly's page.
  kelly is anne's partner.
  brett is logged in, also looking at Kelly's page.
  When anne splitsvilles, brett doesn't find out.
  I think this means that the "viewer.pk" bit of the channel needs to be optional.
  Anyone who looks at a subject will subscribe to that empty-viewer channel, except for ... I guess ... the subject in question, or their partner.

* paginated the player list a while ago, by using datatables, which gives me pagination for free.

* rename the "foo-html-partial.html" files to "foo-partial.html"

* sam is looking at his own page
  bob is looging at sam's page
  They are partners
  sam clicks "Splitsville"
  bob's page doesn't update
  I suspect I need to spray more messages -- one to subject, viewer, and subject's partner

* I am sending the same blob of HTML to all browsers.  Specifically, if abigail and juan are partners, and each is looking at Juan's page, after some splitsville and parter-up, I see
    Hello, Juan
    juan: muh partner
  I think I need the channel to include both the logged-in user, and the "subject" (i.e., the user whose ID is in the URL); only then will the view have enough information to render the stuff correctly.

* BEEG BOOG: logged in as abigail on the phone, looking at the page for alan.
  meanwhile the browser is logged in as juan, and *it* is also looking at alan's page.
  When juan partners up, abigail sees "JUAN is muh partner" and "their partner is you! juan".

  I suspect I wrote the template partial on the assumption that there were only two people in the world -- the player and their partner.

* It should be blindingly obvious that you have a partner so you don't have to go around looking for another one.

* When someone clicks the "partner up" button, the other person needs to get an alert, telling them that that happened.
  And their "player detail" page, or at least some section of it, needs to refresh so that it now says who their partner is.

* When sending a chat message, make RET submit, so that we don't have to actually click on the button.
  Note that simply using htmx with `hx-trigger="keyup[key=='Enter']"` doesn't work on mobile, since they ain't no key events ðŸ˜­

* The chat log can get annoyingly long -- the new messages are at the bottom, so I gotta scroll to see them.

* When sending a chat message, the newly-appended log line isn't styled quite the same as those logs that were sent by the server when the page loaded.

* Write a player-list partial template.  It should include both the "lookin' for love" filter, and a new "are they in the lobby" filter.
  Use that on both "/players/" and "/lobby/" (distinguished only by different default settings on those filters)
  - It's not a partial; I just made "players" do double-duty

* When displaying the signup page, put text focus on the first field, so I can start typing without having to hit TAB

* Refactor: I've got two almost-but-not-quite-identical chunks of HTML for rendering a chat log: one in the lobby, one in the player detail.
  Ideas:
  âœ“ have a separate template that renders just that, and then stick the output of rendering that into the context of both lobby and player_detail
  âœ˜ use [django-template-partials](https://github.com/carltongibson/django-template-partials)
    - of course that will entail me looking again into HTMX 'cuz carlton sez it's the bee's knees

* when bob partners with tonya, I see `2024-08-16T16:08:06.412297+00:00` `bob` `Partnered with tonya` in the lobby chat, but no "tonya partnered with bob".  On the one hand, this seems fine; on the other hand, I expected to see both messages.
  - Calling this "done" without doing anything; the current behavior seems correct.

* combine PlayerMessage with LobbyMessage.  Maybe if the recipient is NULL that means it's a lobby message?  But then what do I do when I want to have messages directed at a table?  Maybe add a "recipient model" column, so that the target of a message can be NULL (meaning lobby), or anything with a django model.

* Inspired by https://spookylukey.github.io/django-views-the-right-way/, convert some CBVs into function-based views.

* Write my own `@logged_in_as_player_required` decorator, that is like `@login_required`, but checks that there is a corresponding Player object, and redirects with an error message.

* the "lookin' for love" dropdown is always set to "unknown" when the page loads, even if a filter is in effect.
  E.g. <http://localhost:8000/players/?&lookin_for_love=true> correctly displays only partner-ess players, but the dropdown shows "Unknown" when it should show "yes".

  Dunno what I did to fix this, really, apart from making it a lot simpler

* investigate partner weirdness.

  - create two unpartnered players -- `just drop pop --tables=0 --players=2` seems to work
  - log in as player 1
  - go to /player/2/; you'll see "Partner Me Up, Daddy-O"
  - duplicate that page.
  - click the button on one of the pages.  It updates appropriately: the button goes away, and it says "Alice is partnered with Bob" or whatever.
  - go to the other page.  Click its button.  You *should* see either the same "Alice is partnered with Bob" page, or even some sort of exception; but instead it just stays as is.
  - reloading the pages sometimes does nothing, sometimes "fixes" them (i.e., shows what I'd expected)
  - no interesting output in either the Unix console or the JS console
  - only clue: browser's developer tools show the POST data as
    `me=1&them=2&action=partnerup&action=partnerup` -- why is the "action" duplicated?
